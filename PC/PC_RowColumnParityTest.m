% Script testing the following statement:
% in a systematic nxn product code array generated 
% through a single linear block code C (n,k) where: 
% P1 is the parity matrix generated by the row encoding, P2 
% is the parity matrix generated by the column enconding, 
% and P3 is the parity matrix generated by the column encoding on P1,
% the rows in [P2 P3] are valid codewords in C. 

startup;
clear all;

% Parameters
%close all
BCHnu=8;
BCHt=2;
BCHe=1;
BCHn=(2^BCHnu)-1;                   % Coded bits, without the extended bits
BCHk=(2^BCHnu)-1-BCHnu*BCHt;        % Information bits

info_bits=randi([0,1],BCHk,BCHk);                               % Generate the info bit matrix
coded_bits=PC_BCH_Encoder(info_bits,BCHnu,BCHt,BCHe);           % Encode the data using a product code

P2=coded_bits(end-(BCHn+BCHe-BCHk)+1:end,1:BCHk);
P3=coded_bits(end-(BCHn+BCHe-BCHk)+1:end,BCHk+1:end);

hat_P3=P3;

% Extended BCH encoding on P2 rows
for ii=1:(BCHn+BCHe-BCHk)
tmp_coded_bits=bchenc_mex(BCHnu,BCHn,BCHt,P2(ii,:));
if BCHe==1 % sum mod2 all the 2^nu-1 bits
        ext_bits=mod(sum(tmp_coded_bits),2);
    elseif BCHe==2 % sum mod2 all even and odd bits
        ext_bits=[mod(sum(tmp_coded_bits(2:2:end-BCHe)),2),mod(sum(tmp_coded_bits(1:2:end-BCHe)),2)];
end
ext_temp_coded_bits=[tmp_coded_bits ext_bits];
hat_P3(ii,:)=ext_temp_coded_bits(end-(BCHn+BCHe-BCHk)+1:end);
end

% Check [P2 P3] that are valid codewords
if isequal(P3,hat_P3)
    disp('Parity rows are valid codewords');
else
    disp('Parity rows are NOT valid codewords');
end




    





